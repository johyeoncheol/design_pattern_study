# 방문자 패턴

방문자 패턴은 공통된 객체의 데이터 구조와 처리를 분리하는 패턴입니다.

 

## 데이터 처리
객체는 데이터와 행위가 있으며 객체의 행위는 데이터를 처리합니다.

 

객체는 데이터와 함수를 하나의 그룹으로 묶어 처리하는데, 이러한 객체의 특성을 캡슐화라고 하며 다른 말로는 번들링이라고도 합니다.

 

캡슐화는 C 언어에서 구조체나 공용체로 데이터만 묶어 처리했습니다.

그러나 구조체와 달리 객체는 함수도 포함합니다.

 

최근의 캡슐화는 데이터와 행위를 위한 메서드 함수를 하나의 객체로 묶어 처리합니다. 캡슐화는 데이터와 행위를 하나의 객체로 만들어 재사용을 늘립니다.

 

외부로부터 은닉화된 데이터에 접근하려면 세터, 게터와 같은 데이터 접근 메서드를 함께 구현해야 합니다. 이러한 메서드는 데이터 캡슐화 처리 시 같이 설계합니다.


캡슐화 된 객체의 메서드는 단순히 데이터에만 접근할 수 있는 것이 아니라 필요시 데이터 가공도 같이 처리합니다.

 

캡슐화된 객체에 데이터를 처리하기 위한 동작을 추가하고 싶은 경우도 있을 것입니다. 일반적으로 객체는 데이터를 처리하기 위한 다수의 행위들을 갖고 있습니다.

 

일반적으로 데이터를 갖고 있는 클래스에 행위 메서드를 삽입합니다.

데이터를 처리하는 행위가 객체에 추가되면 클래스 선언을 수정해야 합니다. 데이터를 처리해야 하는 작업이 늘어날수록 코드 수정이 잦아집니다.
 

객체의 행위의 대부분은 객체 내 데이터를 중심으로 동작을 처리합니다. 하지만 객체의 행위가 다른 객체의 정보를 참조하는 경우도 있습니다.

 

여러 객체에 데이터가 분산된 경우 객체 간 관계가 복잡합니다. 따라서 데이터가 여러 객체로 분산된 경우,객체의 데이터에 접근할 수 있는 구조의 큰 객체가 필요합니다. 큰 객체는 데이터가 포함된 객체를 갖고 있는 복합 객체입니다.

 

복합 객체 생성은 시스템 자원을 소모하며 복잡한 결합 단계가 필요합니다. 하지만 방문자 패턴은 분산된 객체의 데이터와 행위를 순차적으로 접근하여 데이터를 처리할 수 있도록 합니다.

 

## 분리
방문자 패턴은 분산된 객체에서 공통된 처리 로직만 분리합니다. 그리고 공통된 로직 구조로 별도의 객체로 분리합니다.
 


데이터를 포함한 객체에서 행위만 별도의 객체로 분리하면 데이터를 갖고 있는 객체는 크게 수정하지 않고도 행위를 쉽게 변경할 수 있습니다. 객체의 데이터와 행위를 분리함으로써 보다 나은 확장성을 갖게됩니다.

 

## 원소 객체
객체의 데이터와 행위가 다수의 객체로 분산된 경우 방문자 패턴을 활용합니다. 방문자 패턴을 통해 분산된 데이터를 처리하고, 공통된 로직을 부리하여 변경을 쉽게 처리합니다. 방문자 패턴으로 분리된 객체는 데이터와 연산을 쉽게 처리합니다.

 

원소 객체는 데이터를 보관하는 구조 클래스입니다.

 

방문자 패턴의 원소 객체는 외부로부터 자신의 데이터에 접근할 수 있는 수동적 방식을 사용합니다.

 

모든 원소에 구현해야 하는 메서드를 인터페이스로 적용했습니다. 인터페이스를 적용하여 실제 객체를 선언합니다.

 

방문자 패턴은 실제 처리 로직을 다른 객체로 분리하여 위임합니다.

 

모든 원소 객체는 위임을 위해 인터페이스에 선언된 accept() 메서드를 구현하며, accept() 메서드는 매개변수를 통해 위임되는 객체를 전달받습니다.

 

객체는 캡슐화를 통해 데이터와 행위를 은닉할 수 있습니다. 하지만 방문자 패턴은 방문하는 외부 객체에 자신의 모든 데이터와 행위의 접근을 허용합니다.

즉, 캡슐화와 데이터 은닉을 활용할 수 없게 방해하는 요인입니다.

 
